
Chemotion Converter
===================


Chemotion Converter is a very powerful python file converter running as a stand-alone flask server or included in an ELN or scientific Repository (like the [Chemotion ELN](https://chemotion.net/), other ELNs we cannot guarantee) and called via API during file upload. For local and offline users, it is also possible to use it as an CLI tool.
# Readers


A reader is a python class file handling the translation of your input file format to a usable python object. It is created by providing an example file to the developers or python coders and used and defined by the [converter app backend](https://github.com/ComPlat/chemotion-converter-app).

|file name|class name|identifier|priority|check|
| :---: | :---: | :---: | :---: | :---: |
|__init__|None|None|None||
|afm|AfmReader|afm_reader|10|<pre>def check(self):<br>    return self.file.suffix.lower() == '.spm'</pre>|
|aif|AifReader|aif_reader|95|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    if self.file.suffix.lower() in ('.txt', '.aif') and self.file.mime_type == 'text/plain':<br>        first_line = self.file.string.splitlines()[0]<br>        return 'raw2aif' in first_line<br>    return False</pre>|
|asc_zip|AscZipReader|asc_zip_reader|10|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    result = False<br>    if self.file.suffix.lower() == '.zip' and self.file.mime_type == 'application/zip':<br>        with ZipFile(self.file.fp, 'r') as zip_obj:<br>            list_of_file_names = zip_obj.namelist()<br>            if any((fileName.lower().endswith('.asc') for fileName in list_of_file_names)):<br>                with tempfile.TemporaryDirectory() as td:<br>                    zipdir = os.path.join(td, os.path.basename(self.file.name))<br>                    os.makedirs(zipdir)<br>                    result = True<br>                    for file_name in list_of_file_names:<br>                        if file_name.lower().endswith('.asc'):<br>                            path_file_name = zip_obj.extract(file_name, zipdir)<br>                            with open(path_file_name, mode='r', encoding='latin_1') as f:<br>                                self.filedata[file_name] = f.readlines()<br>    return result</pre>|
|ascii|AsciiReader|ascii_reader|1000|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    return not self.file.encoding == 'binary'</pre>|
|brml|BrmlReader|brml_reader|10|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    return self.file.suffix == '.brml'</pre>|
|brucker_dotzero|DotZeroReader|dot_zero_reader|79|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    dotzero_extentions = ['.0']<br>    if self.is_tar_ball:<br>        for x in self.file_content:<br>            try:<br>                if opusFC.isOpusFile(x.fp.filename):<br>                    self._dotzero_file = x.fp.filename<br>                    return True<br>            except (ValueError, TypeError, FileNotFoundError):<br>                pass<br>        dx_file = next((x for x in self.file_content if x.suffix.lower() == '.dx'), None)<br>        if dx_file is not None:<br>            self._dx_name = dx_file.name[:-3]<br>    elif self.file.suffix.lower() in dotzero_extentions:<br>        with tempfile.NamedTemporaryFile(suffix='.0', delete=False) as temp_file:<br>            self._dotzero_file = temp_file.name<br>            self.file.fp.save(self._dotzero_file)<br>            self._has_temp_copy = True<br>            if opusFC.isOpusFile(self._dotzero_file):<br>                return True<br>            return False<br>    return self._dotzero_file is not None</pre>|
|cary|CaryReader|cary_reader|90|<pre>def check(self):<br>    result = self.check_csv()<br>    if result:<br>        split = re.split('(?:\\r?\\n){2,}', self.file.string.strip())<br>        metadata_string = data_string = None<br>        try:<br>            data_string, metadata_string = split<br>        except ValueError:<br>            result = False<br>        if result and 'Instrument  Cary' in metadata_string:<br>            self.rows = list(csv.reader(io.StringIO(data_string), self.file.features('csv_dialect')))<br>            self.lines = data_string.splitlines()<br>            self.metadata_lines = metadata_string.splitlines()<br>        else:<br>            result = False<br>    logger.debug('result=%s', result)<br>    return result</pre>|
|cfx|CfxReader|cfx_reader|11||
|cif|CifReader|cif_reader|10|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    if self.file.suffix.lower() == '.zip' and self.file.mime_type == 'application/zip':<br>        with ZipFile(self.file.fp, 'r') as zip_obj:<br>            try:<br>                file_name = next((x for x in zip_obj.namelist() if x.lower().endswith(self.file_prefix)))<br>                with os.path.join(tempfile.TemporaryDirectory().name, self.file.name) as zipdir:<br>                    os.makedirs(zipdir)<br>                    path_file_name = zip_obj.extract(file_name, zipdir)<br>                    with open(path_file_name, 'rb') as f:<br>                        fs = FileStorage(stream=f, filename=os.path.basename(file_name), content_type='chemical/x-cif')<br>                        self.file = File(fs)<br>            except:<br>                logger.debug('result=%s', False)<br>                return False<br>    result = self.file.suffix.lower() == self.file_prefix and self.file.mime_type == 'text/plain'<br>    if result:<br>        try:<br>            self.cif = cif.read_string(self.file.content)<br>        except ValueError as e:<br>            if str(e).endswith('expected block header (data_)'):<br>                content = 'data_' + re.split('^data_', self.file.string, flags=re.M)[-1]<br>                try:<br>                    self.cif = cif.read_string(content)<br>                except ValueError:<br>                    result = False<br>    return result</pre>|
|csm|CsmReader|csm_reader|10|<pre>def check(self):<br>    is_check = super().check()<br>    if is_check:<br>        return '<div id="metainfo">' in self.file.string</pre>|
|csv_reader|CSVReader|csv_reader|100|<pre>def check(self):<br>    result = self.check_csv()<br>    if result:<br>        self.lines = self.file.string.splitlines()<br>        try:<br>            self.rows = list(csv.reader(io.StringIO(self.file.string), self.file.features('csv_dialect')))<br>        except:<br>            self.rows = list(csv.reader(self.lines, self.file.features('csv_dialect')))<br>    logger.debug('result=%s', result)<br>    return result</pre>|
|dsp|DSPReader|dsp_reader|95|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    if self.file.suffix.lower() == '.dsp' and self.file.mime_type == 'text/plain':<br>        first_line = self.file.string.splitlines()[0]<br>        return 'sinacsa' in first_line<br>    return False</pre>|
|dta|DtaReader|dta_reader|10|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    return self.file.encoding != 'binary' and self.file.suffix.lower() == '.dta'</pre>|
|dwl|_ReaderSate|dwl-reader|11|<pre>def check(self):<br>    result = self.file.suffix.lower() == '.result' and self.file.mime_type == 'text/plain'<br>    if result:<br>        self.lines = self.file.string.splitlines()<br>        try:<br>            result = re.match('^<[^>]+>$', self.lines[0]) is not None or self.lines[1].startswith('Start') or self.lines[2].startswith('Status')<br>        except IndexError:<br>            result = False<br>    if result:<br>        self._check_next_tag(self.lines[0])<br>    return result</pre>|
|ea_pdf|EaPdfReader|pdf_ea_reader|99|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    res = super().check()<br>    if res:<br>        res = len(self.text_data) == 1 and '_' in self.text_data and self.text_data['_'][-1]['text'].strip().startswith('Signature')<br>    return res</pre>|
|ebl|_State|ebl_reader|50|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    result = self.file.suffix.lower() == '.log' and self.file.mime_type == 'text/plain'<br>    if result:<br>        self.lines = self.file.string.splitlines()<br>        self.pre_header, self.pre_script, result = self._PreProcessor.process_header(self.lines[:self._PreProcessor.header_lines])<br>    return result</pre>|
|excel|ExcelReader|excel_reader|15|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    if self.file.encoding != 'binary':<br>        result = False<br>    elif self.file.suffix != '.xlsx':<br>        result = False<br>    else:<br>        try:<br>            self.wb = openpyxl.load_workbook(filename=self.file.fp)<br>            result = True<br>        except (openpyxl.utils.exceptions.InvalidFileException, zipfile.BadZipFile):<br>            result = False<br>    logger.debug('result=%s', result)<br>    return result</pre>|
|gcd|GcdReader|gcd_reader|5|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    if self.is_tar_ball:<br>        self.file = next((x for x in self.file_content if x.name.lower().endswith('.gcd.txt')), None)<br>        if self.file is None:<br>            return False<br>    result = self.file.suffix.lower() == '.txt'<br>    if result:<br>        self.lines = self._parse_input()<br>        result = '[Chromatogram (Ch1)]' in self.lines and '[Compound Results(Ch1)]' in self.lines<br>    return result</pre>|
|hplc_reader|HplcReader|hplc_reader|5|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    if self.is_tar_ball:<br>        try:<br>            if len(self.file_content) > 1:<br>                self.df = ph.read_chromatograms(self.file_content[0].file_path)<br>            else:<br>                return False<br>            return True<br>        except ValueError:<br>            pass<br>    return False</pre>|
|html|HtmlReader|html_reader|100|<pre>def check(self):<br>    return self.file.suffix.lower() == '.html'</pre>|
|jasco|JascoReader|jasco_reader|99|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    result = False<br>    if self.file.string is not None:<br>        if len(self.file.string.splitlines()) == 1:<br>            file_lines = self.file.string.split(',')<br>            if len(file_lines) > self.header_length - 1 and file_lines[self.header_length - 1] == str(len(file_lines) - self.header_length):<br>                result = True<br>                self.lines = file_lines<br>    return result</pre>|
|jcamp_conv_reader|JcampReader|jcamp_reader|80|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    jsamp_extentions = ['.dx', '.jdx', '.jcm']<br>    if self.is_tar_ball:<br>        self.file = next((x for x in self.file_content if x.suffix.lower() in jsamp_extentions), None)<br>        if self.file is None:<br>            return False<br>    result = self.file.suffix.lower() in jsamp_extentions<br>    logger.debug('result=%s', result)<br>    return result</pre>|
|json_reader|JsonReader|json_reader|20|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    return self.file.suffix.lower() == '.json'</pre>|
|lithoz_pdf|PdfLithozReader|pdf_lithoz_reader|99|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    res = super().check()<br>    if res:<br>        res = len(self.text_data) == 6 and 'Zusammenfassung' in self.text_data<br>    return res</pre>|
|nova|NovaReader|nova_reader|90|<pre>def check(self):<br>    result = self.check_csv()<br>    if result:<br>        first_line = self.file.string.splitlines()[0]<br>        first_row = next(csv.reader(io.StringIO(first_line), self.file.features('csv_dialect')))<br>        if first_row[:8] == self.first_row:<br>            self.rows = list(csv.reader(io.StringIO(self.file.string), self.file.features('csv_dialect')))<br>            self.lines = self.file.string.splitlines()<br>        else:<br>            result = False<br>    logger.debug('result=%s', result)<br>    return result</pre>|
|old_excel|OldExcelReader|old_excel_reader|16|<pre>def check(self):<br>    if self.file.encoding != 'binary' or self.file.suffix != '.xls':<br>        return False<br>    try:<br>        self.wb = xlrd.open_workbook(file_contents=self.file.content)<br>        return True<br>    except:<br>        return False</pre>|
|pdf|PdfReader|pdf_reader|100|<pre>def check(self):<br>    result = self.file.suffix == '.pdf'<br>    if result:<br>        self.text_data = self._read_pdf()<br>    return result</pre>|
|pssession|PsSessionReader|pssession_reader|10|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    return self.file.suffix == '.pssession'</pre>|
|sec|SecReader|sec_reader|95|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    result = False<br>    if self.file.suffix.lower() == '.txt' and self.file.mime_type == 'text/plain':<br>        first_lines = [self.file.string.splitlines()[0], self.file.string.splitlines()[1], self.file.string.splitlines()[2]]<br>        result_a = 'Sample :' in first_lines[0] and 'Method settings :' in first_lines[1] and ('Sequence table :' in first_lines[2])<br>        result_b = 'Sample :' in first_lines[0] and 'Inject date :' in first_lines[1] and ('Inject volume :' in first_lines[2])<br>        result = result_a or result_b<br>    return result</pre>|
|sem|SemReader|sem_reader|95|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    result = False<br>    if super().check():<br>        first_line = self.file.string.splitlines()[0]<br>        result = first_line.startswith('$SEM_DATA_VERSION')<br>    return result</pre>|
|tif|TifReader|tif_reader|96|<pre>def check(self):<br>    result = False<br>    if self.file.suffix.lower() == '.tif' and self.file.mime_type == 'image/tiff':<br>        self._parsed_values = self._read_img()<br>        result = self._parsed_values is not None and len(self._parsed_values) > 0<br>    return result</pre>|
|uvvis|UvvisReader|uvvis_reader|10|<pre>def check(self):<br>    """<br>        :return: True if it fits<br>        """<br>    result = super().check()<br>    if result:<br>        metadata_begin = self.lines[-2] if len(self.lines) > 1 else ''<br>        return 'Properties' in metadata_begin<br>    return result</pre>|
|uxd_reader|UXDReader|uxd_reader|10|<pre>def check(self):<br>    return self.file.suffix.lower() in self._file_extensions</pre>|
|vsi|VsiReader|vsi_reader|8|<pre>def check(self):<br>    if not super().check():<br>        return False<br>    text = self.file.string[:500]<br>    result = '<DataContainer key="MetaData" typeid=' in text<br>    result &= '<DataContainer typeid=' in text<br>    return result</pre>|
|xml_reader|XMLReader|xml_reader|10|<pre>def check(self):<br>    return self.file.suffix.lower() in self._file_extensions</pre>|
|xrdml|XRDMLReader|xrdml_reader|None||

# Profiles


A profile is JSON file defining a ruleset on how to convert your input file. Normally, it is created by uploading an example of your input file to the GUI of the [converter client frontend](https://github.com/ComPlat/chemotion-converter-client).

|id|reader|extension|title|description|devices|software|identifiers|
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|0d7dd8d4-a599-4151-855e-643956a7362c|BrmlReader|.brml|X-ray diffraction data from brml, data: +, metadata: -|---; ref location: ---, data: +, metadata: -|[]|[]|[('extension', '.brml')]|
|df15f2b0-4133-4231-8b48-bec52fb6043c|CifReader|.cif|crystallographic metadata from cif, data: -, metadata: +|Stoe StadiVari diffractometer; ref location: KIT CN, data: +, metadata: +|[]|[]|[('extension', '.cif'), ('reader', 'CifReader')]|
|0d04f3c5-43d4-408a-85ef-34b33975020a|CSVReader|.csv|DSC with Time|differential scanning calorimetry|[]|[]|[('reader', 'CSVReader'), ('extension', '.csv'), ('column_02', 'DSC/(mW/mg)'), ('column_00', '##Temp./°C')]|
|3e2fb90e-b6b6-4152-9182-ed8e203a58b5|CSVReader|.csv|DSC without time|differential scanning calorimetry|[]|[]|[('reader', 'CSVReader'), ('column_01', 'DSC/(mW/mg)'), ('column_00', '##Temp./°C'), ('extension', '.csv')]|
|8079b064-6314-4d99-b13b-e4f590cf556f|CSVReader|.csv|UV-VIS data from csv, data: +, metadata: -|Cary 60; ref location: KIT CN, data: +, metadata: +|[]|[]|[('column_00', 'Wavelength'), ('column_01', 'Abs')]|
|c498c925-61e0-455e-a4c6-c46ac9c2f5c6|CSVReader|.csv|Mass spectrometry from txt, data: +, metadata: -|Finnigian MAT8230, ref location: ---, data: +, metadata: -|[]|[]|[]|
|d8e6bf8f-6de1-4743-9513-04cbd0c6c712|CSVReader|.csv|UVVIS CS|multicolumn (4) file with no header - Data from Tasnim|[]|[]|[('reader', 'CSVReader'), ('extension', '.csv'), ('column_00', 'Wavelength (nm)'), ('column_07', 'Abs')]|
|db05bfb4-6829-4339-bec1-54065710f211|CSVReader|.csv|UV-VIS data from multi-column csv, data: +, metadata: -|Cary 60; ref location: KIT CN, data: +, metadata: +|[]|[]|[('content_type', 'text/csv')]|
|0cd6596c-83d2-49ab-a982-1dfec98d16ba|CSVReader|.dpt|IR DPT|IR-Alpha (CS)|[]|[]|[('extension', '.dpt')]|
|799f3db4-fd21-4aa7-a7bd-7c5548cbe316|DtaReader|.DTA|CV Gamry||[]|[]|[('extension', '.DTA'), ('TITLE', 'Cyclic')]|
|8b00e934-9bc4-4248-a2de-b303d2e93aa4|DtaReader|.DTA|## Nameless (04/12/2025 14:33:36)|Test|['g', 'a']|['windows', 'x', 'linux']|[('file_name', 'DHM-12-CV-1mM+1mMFc-N2_100mVps-No9.DTA')]|
|12b1ff4b-e295-4377-ba11-c602d855a644|HplcReader|.gz|Chemstation||[]|[]|[('reader', 'HplcReader'), ('mime_type', 'application/gzip'), ('internal_reader_name', 'chemstation')]|
|8c8c4b18-143a-4245-a8d4-29e47c6b86a1|BioLogic|.gz|Biologic as tar gz|CV Files|[]|[]|[('reader', 'BioLogic'), ('settings.technique', 'CV')]|
|d7729388-8350-402c-b617-82a6fa4900dd|LcmsReader|.gz|LcmsReader|OpenLab|[]|[]|[('content_type', 'application/x-gzip'), ('extension', '.gz'), ('reader', 'LcmsReader')]|
|c6573972-cb06-484d-a529-9dd2424fc408|PsSessionReader|.pssession|CV data from pssession, data: +, metadata: +|PalmSens PSTrace; ref location: IPB Leibniz, data: +, metadata: +|[]|[]|[('extension', '.pssession'), ('title', '(Cyclic Voltammetry)')]|
|2a913039-c48d-4fd5-9fbb-706733e53f76|CSVReader|.txt|UV-Vis|UV Vis INT (FI)|[]|[]|[('reader', 'CSVReader')]|
|44f5bfbb-ae1f-4da0-b43b-0d33b649c24a|SecReader|.TXT|SEC 1|Size Exclusion Chromatography (SEC)<br>with one Detector Output|[]|[]|[('reader', 'SecReader'), ('table_name', 'MWD'), ('Detector 1', 'I1')]|
|5a413afd-cb77-40e4-99b1-c044d94eaa51|CSVReader|.txt|UV-VIS data from general txt, data: +, metadata: -|generic data table only; ref location: ---, data: +, metadata: -|[]|[]|[]|
|5cb879d1-2b3f-4778-8e06-1a198500c8db|AifReader|.txt|(AIF) Sorption-Desorption Measurement from txt, data: +, metadata: +|---; ref location: TU Dresden, data: +, metadata: + <br>|[]|[]|[('reader', 'AifReader'), ('Unit_column_#0', '_adsorp_pressure')]|
|6bb4fea5-3a59-4b95-8956-d977a4d8b6a7|NovaReader|.txt|CV data from txt, data: +, metadata: (+)|Metrohm Autolab Nova; ref location: Uni Aachen, data: +, metadata: (-)<br>;(basic Metadata calculation done by Reader)|[]|[]|[('reader', 'NovaReader'), ('column_00', 'Potential applied (V)'), ('column_02', 'WE(1).Current (A)')]|
|6be46fd7-59a2-4b02-829b-cbfef8c19646|CSVReader|.txt|UV-VIS data from txt, data: +, metadata: -|JASCO V-570; ref location: KIT CN, data: +, metadata: +|[]|[]|[('extension', '.txt')]|
|6d344bc4-c4fb-4306-9d56-1e754e7e0590|CSVReader|.txt|Tensile test data from txt, data: +, metadata: -|Inspect Table 50kN; ref location: Fraunhofer IWS, data: +, metadata: -<br>;LowTemp|[]|[]|[('column_01', 'Force_N'), ('column_05', 'Elongation_%'), ('column_02', 'Strain_mm')]|
|71883827-4472-48d8-becf-64ea89324f3e|SecReader|.TXT|SEC 2|Size Exclusion Chromatography with two Detector Outputs|[]|[]|[('reader', 'SecReader'), ('table_name', 'MWD'), ('Detector 2', 'I2')]|
|a5b05507-aed2-462b-a526-3fee53c87a48|CSVReader|.txt|DLS data from txt, data: +, metadata: -|---; ref location: ---, data: +, metadata: -<br>;Subtype 1|[]|[]|[('file_name', 'SSP-0'), ('extension', '.txt')]|
|af891148-ebcc-4e5d-a481-fa6acc853699|CSVReader|.txt|UV-VIS data from txt, data: +, metadata: -|Horiba Duetta; ref location: KIT CN, data: +, metadata: +|[]|[]|[]|
|b31ef3df-eacf-4440-bbb3-34b073be9eb9|CSVReader|.txt|CD MS Spectra data from txt, data: +, metadata: -|LCMSsolution; ref location: KIT CN, data: +, metadata: + ;Subtype 2|[]|[]|[('reader', 'CSVReader')]|
|c7e3130f-6c23-432a-a886-a82d11632da2|CSVReader|.txt|UV-Vis|UV-Vis (AK Théato Seminar) - Campus West, KIT|[]|[]|[('reader', 'CSVReader')]|
|c9d63af9-2ce7-425e-895c-c04b8497c26c|CSVReader|.txt|Tensile test data from txt, data: +, metadata: -|Inspect Table 50kN; ref location: Fraunhofer IWS, data: +, metadata: - <br>;HighTemp|[]|[]|[('column_01', 'Force_N'), ('column_02', 'Deformation (fine)_mm'), ('column_05', 'Strain_mm')]|
|cddfe1ff-ef5a-44fb-a6ba-443a870c7a27|CSVReader|.txt|Emission spectrum|(fluorescence) emission spectrum with generic dataset (FI)|[]|[]|[('reader', 'CSVReader')]|
|d9be2928-fd8e-4abe-bbe0-3e419330875f|CSVReader|.txt|DLS data from txt, data: +, metadata: -|---; ref location: ---, data: +, metadata: -<br>;Subtype 2|[]|[]|[('extension', '.txt'), ('file_name', 'IW-SPEGA')]|
|fb19f78e-8d87-4c5f-a4e1-ac90994300d7|CSVReader|.txt|CD MS Spectra data from txt, data: +, metadata: -|LCMSsolution; ref location: KIT CN, data: +, metadata: +<br>;Subtype 1|[]|[]|[('reader', 'CSVReader'), ('column_00', 'm/z')]|
|e7a4ee04-cdf6-4da6-a82c-ba6909af6cee|OldExcelReader|.xls|TGA|TGA - Campus West, KIT with Isothermal|[]|[]|[('reader', 'OldExcelReader'), ('Instrument Type', 'TGA5500')]|
|e845bc85-07b9-4e21-8bdf-4daa4a74fa15|OldExcelReader|.xls|TGA with derivative|TGA - Campus West, KIT with Isothermal<br>and Derivative|[]|[]|[('reader', 'OldExcelReader'), ('Instrument Type', 'TGA5500')]|
|fb63e718-3842-4d45-9b39-84a53b27e483|OldExcelReader|.xls|TGA 2|TGA - Campus West, KIT without Isothermal|[]|[]|[('reader', 'OldExcelReader'), ('Instrument Type', 'TGA5500')]|
|15400217-b730-47db-9d5c-a300bce7ae95|ExcelReader|.xlsx|UVVIS CS|multicolumn (2) XLSX file with header at the end - Data from Tasnim|[]|[]|[('reader', 'ExcelReader'), ('extension', '.xlsx')]|
|e10cd71e-b44f-4493-b7ad-ca231ccd324f|ExcelReader|.xlsx|DLS|DLS intensity INT (FI)|[]|[]|[('reader', 'ExcelReader')]|
|fbbe088a-b688-4609-8c00-086a149f61ba|ExcelReader|.xlsx|DLS-ACF|ACF - INT (FI)|[]|[]|[('reader', 'ExcelReader')]|
|4d4f72ef-3708-4516-b110-2fa6869565ce|AsciiReader|.xy|PXRD data from xy, data: +, metadata: -|??? ; ref location: ???, data: +, metadata: as comment|None|None|[('extension', '.xy'), ('reader', 'AsciiReader')]|
|5b206281-49f6-437b-99ca-c64a621eb903|AsciiReader|.xy|Mass spectrometry from general xy format, data: +, metadata: -|generic data table only; ref location: Uni Aachen, data: +, metadata: -|[]|[]|[]|
